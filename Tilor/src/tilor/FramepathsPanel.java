/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package tilor;

import java.io.File;
import java.util.ArrayList;
import javax.swing.JFileChooser;
import java.util.HashMap;
import javax.swing.filechooser.FileNameExtensionFilter;

/**
 *
 * @author seanlanghi
 */
public class FramepathsPanel extends javax.swing.JPanel
     implements SaveLoadProtocol
{

    /*
     *  Human-added private fields.
     */
    
    private File[] lastFilesChosen;
    private ArrayList<String> framepathList;
    private TilorDelegate delegate = null;
   
    /*
     *  Human-added protocol implementation.
     */

    @Override
    public HashMap <String, Object> getData()
    {
        HashMap <String, Object> data = new HashMap<String,Object>();
        // All we're responsible for returning is the list of framepaths.
        data.put("framepaths", framepathList);
        return data;
    }
    
    @Override
    public void loadDataFromMap(HashMap <String, Object> map)
             throws MissingDataException
    {
        // First see if the map we're loading from has what we're looking for.
        Object valueForKey = map.get("framepaths");
        if (valueForKey == null || ! (valueForKey instanceof ArrayList))
        {
            ArrayList<String> absenteeReport = new ArrayList<String>();
            absenteeReport.add("framepaths");
            throw new MissingDataException(absenteeReport);
        }
        
        ArrayList<String> framepathList = (ArrayList<String>)valueForKey;
     
        this.framepathList.clear();
        this.framepathList = framepathList;
        propagateFramepathListUpdate();
    }

    /*
     *  Human-added public instance methods.
     */
    
    public ArrayList<String> getFramepaths()
    {
        return framepathList;
    }

    public void setDelegate(TilorDelegate delegate)
    {
        this.delegate = delegate;
    }

    public TilorDelegate getDelegate()
    {
        return delegate;
    }
    
    public void addFramepaths()
    {
        // Create a file chooser that will let the user browse for one or more files.
        JFileChooser framepathBrowser;
        if (lastFilesChosen == null)
            framepathBrowser = new JFileChooser();
        else
            framepathBrowser = new JFileChooser(lastFilesChosen[0]);

        // Allow the user to select multiple files at once.
        framepathBrowser.setMultiSelectionEnabled(true);

        // Restrict selection to image files.
        framepathBrowser.setAcceptAllFileFilterUsed(false);
        FileNameExtensionFilter imagesOnly =
        new FileNameExtensionFilter("Image Files (GIF, JPEG, PNG, TGA, TIFF, BMP)",
            "png", "jpg", "jpeg", "gif", "tga", "bmp", "tif", "tiff");
        framepathBrowser.setFileFilter(imagesOnly);

        // Launch the file chooser.
        int browsingResult = framepathBrowser.showDialog(this.getParent(), "Choose");
        if (browsingResult == JFileChooser.APPROVE_OPTION)
        {
            // Save the chosen files' paths and add them to the list of framepaths.
            lastFilesChosen = framepathBrowser.getSelectedFiles();
            String relPath;
            for (File file : lastFilesChosen)
            {
                relPath = this.delegate.getRelativePathFromProjectHomeDir(file.getAbsolutePath());
                framepathList.add(relPath);
            }

            // Notify relevant systems that the framepath list has changed.
            propagateFramepathListUpdate();
        }
    }
    
    public void removeAllFramepaths()
    {
        framepathList.clear();
        propagateFramepathListUpdate();
    }
    
    /*
     *  Human-added private instance methods.
     */
    
    private void propagateFramepathListUpdate()
    {
        // Update the GUI to reflect the change.
        framepathListDisplay.setListData(framepathList.toArray());
        framepathListDisplay.updateUI();

        // Notify the delegate of the change.
        this.delegate.framepathListDidUpdate(framepathList);
    }
    
    // -------------------------------------------------------------------------------- //
    // -------------------- Auto-generated code areas begin here. --------------------- //
    // -------------------------------------------------------------------------------- //

    /**
     * Creates new form FramepathsPanel
     */
    public FramepathsPanel()
    {
        initComponents();
        
        lastFilesChosen = null;
        framepathList = new ArrayList<String>();
        framepathListDisplay.setListData(framepathList.toArray());
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents()
    {

        label = new javax.swing.JLabel();
        framepathListWrapper = new javax.swing.JScrollPane();
        framepathListDisplay = new javax.swing.JList();
        addButton = new javax.swing.JButton();
        upButton = new javax.swing.JButton();
        downButton = new javax.swing.JButton();
        deleteButton = new javax.swing.JButton();

        setBackground(new java.awt.Color(100, 200, 200));

        label.setText("Framepaths");

        framepathListDisplay.setModel(new javax.swing.AbstractListModel()
        {
            String[] strings = { "Item 1", "Item 2", "Item 3", "Item 4", "Item 5" };
            public int getSize() { return strings.length; }
            public Object getElementAt(int i) { return strings[i]; }
        });
        framepathListWrapper.setViewportView(framepathListDisplay);

        addButton.setText("\u002B...");
        addButton.addActionListener(new java.awt.event.ActionListener()
        {
            public void actionPerformed(java.awt.event.ActionEvent evt)
            {
                addButtonActionPerformed(evt);
            }
        });

        upButton.setText("\u2191");
        upButton.addActionListener(new java.awt.event.ActionListener()
        {
            public void actionPerformed(java.awt.event.ActionEvent evt)
            {
                upButtonActionPerformed(evt);
            }
        });

        downButton.setText("\u2193");
        downButton.addActionListener(new java.awt.event.ActionListener()
        {
            public void actionPerformed(java.awt.event.ActionEvent evt)
            {
                downButtonActionPerformed(evt);
            }
        });

        deleteButton.setText("\u2717");
        deleteButton.addActionListener(new java.awt.event.ActionListener()
        {
            public void actionPerformed(java.awt.event.ActionEvent evt)
            {
                deleteButtonActionPerformed(evt);
            }
        });

        org.jdesktop.layout.GroupLayout layout = new org.jdesktop.layout.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(layout.createSequentialGroup()
                .addContainerGap()
                .add(layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
                    .add(layout.createSequentialGroup()
                        .add(addButton, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 1, Short.MAX_VALUE)
                        .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                        .add(deleteButton, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 32, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                        .add(71, 71, 71)
                        .add(upButton, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 27, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                        .add(downButton, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 29, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE))
                    .add(layout.createSequentialGroup()
                        .add(layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
                            .add(framepathListWrapper, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 200, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                            .add(label))
                        .add(0, 0, Short.MAX_VALUE)))
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(layout.createSequentialGroup()
                .addContainerGap()
                .add(label)
                .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                .add(framepathListWrapper, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 231, Short.MAX_VALUE)
                .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                .add(layout.createParallelGroup(org.jdesktop.layout.GroupLayout.BASELINE)
                    .add(addButton, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .add(upButton)
                    .add(downButton)
                    .add(deleteButton))
                .addContainerGap())
        );
    }// </editor-fold>//GEN-END:initComponents

    // Add framepaths to the list.
    private void addButtonActionPerformed(java.awt.event.ActionEvent evt)//GEN-FIRST:event_addButtonActionPerformed
    {//GEN-HEADEREND:event_addButtonActionPerformed
        addFramepaths();
    }//GEN-LAST:event_addButtonActionPerformed

    // Deletes selected framepaths from the list.
    private void deleteButtonActionPerformed(java.awt.event.ActionEvent evt)//GEN-FIRST:event_deleteButtonActionPerformed
    {//GEN-HEADEREND:event_deleteButtonActionPerformed
        // Do nothing if no list items were selected.
        if (framepathListDisplay.isSelectionEmpty())
        {
            return;
        }

        int[] selectionIndices = framepathListDisplay.getSelectedIndices();
        String[] stringsToDelete = new String[selectionIndices.length];

        // Figure out which framepath strings we're supposed to delete.
        for (int i = 0; i < selectionIndices.length; i++)
        {
            stringsToDelete[i] = framepathList.get(selectionIndices[i]);
        }

        // Delete the indicated framepath strings.
        for (int i = 0; i < stringsToDelete.length; i++)
        {
            framepathList.remove(stringsToDelete[i]);
        }
        
        // Notify relevant systems that the framepath list has changed.
        propagateFramepathListUpdate();

        // Remove the selection highlight from the GUI list display.
        framepathListDisplay.clearSelection();
    }//GEN-LAST:event_deleteButtonActionPerformed

    // Moves selected framepaths up by one position in the list.
    private void upButtonActionPerformed(java.awt.event.ActionEvent evt)//GEN-FIRST:event_upButtonActionPerformed
    {//GEN-HEADEREND:event_upButtonActionPerformed
        // Do nothing if no list items were selected.
        if (framepathListDisplay.isSelectionEmpty())
        return;

        int[] selectionIndices = framepathListDisplay.getSelectedIndices();
        int numSelections = selectionIndices.length;
        String[] stringsToMove = new String[selectionIndices.length];

        // Figure out which framepath strings we're supposed to move.
        for (int i = 0; i < numSelections; i++)
        {
            stringsToMove[i] = framepathList.get(selectionIndices[i]);
        }

        // Move the indicated framepath strings up by one position.
        int minimumEligibleIndex = 1;
        int thisIndex;
        for (int i = 0; i < numSelections; i++)
        {
            // Query the list position of the string we're looking at.
            thisIndex = framepathList.indexOf(stringsToMove[i]);

            // Don't try to up-shift a frame or a frame cluster if it's already at the top of the list.
            if (thisIndex < minimumEligibleIndex)
            {
                minimumEligibleIndex += 1;
                continue;
            }

            // Yank the string out of the list, then re-add it one slot prior.
            framepathList.remove(stringsToMove[i]);
            framepathList.add(thisIndex - 1, stringsToMove[i]);
        }

        // Update the GUI to reflect the changes.
        framepathListDisplay.setListData(framepathList.toArray());

        // Allow the list selection highlights to persist in a way that agrees with the now-complete shift operation.
        int [] newIndices = new int[numSelections];
        for (int i = 0; i < numSelections; i++)
        {
            if (selectionIndices[i] < minimumEligibleIndex)
            newIndices[i] = selectionIndices[i];
            else
            newIndices[i] = selectionIndices[i] - 1;
        }
        framepathListDisplay.setSelectedIndices(newIndices);

        framepathListDisplay.updateUI();

        // Notify the delegate of the change.
        this.delegate.framepathListDidUpdate(framepathList);
    }//GEN-LAST:event_upButtonActionPerformed

    // Moves selected framepaths down by one position in the list.
    private void downButtonActionPerformed(java.awt.event.ActionEvent evt)//GEN-FIRST:event_downButtonActionPerformed
    {//GEN-HEADEREND:event_downButtonActionPerformed
        // Do nothing if no list items were selected.
        if (framepathListDisplay.isSelectionEmpty())
        return;

        int[] selectionIndices = framepathListDisplay.getSelectedIndices();
        int numSelections = selectionIndices.length;
        String[] stringsToMove = new String[selectionIndices.length];

        // Figure out which framepath strings we're supposed to move.
        // Populate the stringsToMove[] array in reverse, storing lower-down items first.
        // This enables proper edge behavior.
        for (int i = 0; i < numSelections; i++)
        {
            stringsToMove[i] = framepathList.get(selectionIndices[(numSelections - (i + 1))]);
        }

        // Move the indicated framepath strings down by one position.
        int maximumEligibleIndex = framepathList.size() - 2;
        int thisIndex;
        for (int i = 0; i < numSelections; i++)
        {
            // Query the list position of the string we're looking at.
            thisIndex = framepathList.indexOf(stringsToMove[i]);

            // Don't try to down-shift a frame or a frame cluster if it's already at the bottom of the list.
            if (thisIndex > maximumEligibleIndex)
            {
                maximumEligibleIndex -= 1;
                continue;
            }

            // Yank the string out of the list, then re-add it one slot lower.
            framepathList.remove(stringsToMove[i]);
            framepathList.add(thisIndex + 1, stringsToMove[i]);
        }

        // Update the GUI to reflect the changes.
        framepathListDisplay.setListData(framepathList.toArray());

        // Allow the list selection highlights to persist in a way that agrees with the now-complete shift operation.
        int [] newIndices = new int[numSelections];
        for (int i = 0; i < numSelections; i++)
        {
            if (selectionIndices[i] > maximumEligibleIndex)
            newIndices[i] = selectionIndices[i];
            else
            newIndices[i] = selectionIndices[i] + 1;
        }
        framepathListDisplay.setSelectedIndices(newIndices);

        framepathListDisplay.updateUI();

        // Notify the delegate of the change.
        this.delegate.framepathListDidUpdate(framepathList);
    }//GEN-LAST:event_downButtonActionPerformed

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton addButton;
    private javax.swing.JButton deleteButton;
    private javax.swing.JButton downButton;
    private javax.swing.JList framepathListDisplay;
    private javax.swing.JScrollPane framepathListWrapper;
    private javax.swing.JLabel label;
    private javax.swing.JButton upButton;
    // End of variables declaration//GEN-END:variables
}
